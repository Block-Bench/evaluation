{
  "id": "rari_capital_2022",
  "exploit_name": "Rari Capital Fuse",
  "date": "2022-05-08",
  "blockchain": "ethereum",
  "amount_stolen_usd": "80000000",
  "amount_stolen_crypto": "Various",
  "vulnerability_type": "reentrancy",
  "attack_type": "cross_function_reentrancy",
  "difficulty": 4,
  "impact": "critical",
  "description": "Cross-function reentrancy attack. The borrow function sent ETH before final health check, allowing attacker to call exitMarket during callback and bypass collateral requirements.",
  "root_cause": "Cross-function reentrancy. Borrow sent ETH (triggering callback) before final validation. Attacker called exitMarket during callback, modifying shared state (inMarket) and bypassing health checks.",
  "attack_scenario": "Attacker deposited collateral and entered market, called borrow to get ETH. During ETH transfer callback, attacker called exitMarket to remove collateral requirement. Final health check used stale state, allowing over-borrowing.",
  "vulnerable_contract": "rari_capital.sol",
  "vulnerable_function": "borrow",
  "vulnerable_lines": [110, 114, 125],
  "fix_description": "Use global ReentrancyGuard on all functions that share state. Perform all validations after external calls. Prevent exitMarket when positions are open. Consider mutex locks for cross-function protection.",
  "tags": [
    "reentrancy",
    "cross-function",
    "oracle-manipulation",
    "lending",
    "health-check"
  ],
  "references": [
    "https://www.blocksecteam.com/blog/2022/05/rari-capital-fuse-pool-hack/",
    "https://twitter.com/FeiProtocol/status/1520847142650499072"
  ],
  "historical_significance": "Demonstrated sophisticated cross-function reentrancy. Shows that per-function reentrancy guards aren't sufficient when multiple functions share state.",
  "compiler_version": "0.8.0",
  "is_pre_cutoff": true,
  "cutoff_date": "2024-01-01",
  "contract_file": "contracts/tc_010.sol",
  "subset": "annotated",
  "original_subset": "temporal_contamination"
}