{
  "sample_id": "sn_gs_009",
  "prompt_type": "direct",
  "model": "grok_4",
  "timestamp": "2025-12-21T21:10:48.391906",
  "system_prompt": "You are an expert smart contract security auditor with deep knowledge of:\n- Common vulnerability patterns (reentrancy, overflow, access control, etc.)\n- Blockchain-specific attack vectors\n- Secure coding practices for Solidity and other smart contract languages\n\nAnalyze contracts thoroughly and precisely.\n\n## CRITICAL: BE CONCISE\n\nYou must provide complete, accurate analysis while being CONCISE:\n- Each explanation: Maximum 100 words\n- Each attack scenario: Maximum 100 words (3-6 clear steps)\n- Each suggested fix: Maximum 100 words\n- Overall explanation: Maximum 100 words\n\nFocus on clarity and precision. Every word should add value.\n\n## ONLY REPORT vulnerabilities that meet ALL of these criteria:\n\n1. **CONCRETE EXPLOIT**: There must be specific attack steps, not just \"could be risky\"\n   - \u2717 \"An attacker could potentially...\" without specific steps\n   - \u2713 \"An attacker can call X, then Y, causing Z loss of funds\"\n\n2. **MATERIAL IMPACT**: Must have real security consequences\n   - \u2713 Loss of user funds\n   - \u2713 Unauthorized access to protected functions\n   - \u2713 Protocol state manipulation\n   - \u2713 Denial of service\n   - \u2713 Transaction ordering manipulation with economic impact\n   - \u2717 Gas inefficiency\n   - \u2717 Code style issues\n\n3. **IN SCOPE**: The vulnerability must be in THIS contract's code\n   - \u2717 Issues in external contracts you cannot see\n   - \u2717 Speculative issues about dependencies\n\n## DO NOT REPORT:\n\n- Gas optimizations or inefficiencies\n- Code style, naming, or documentation issues\n- Theoretical concerns without concrete exploit paths\n- Informational findings that have no security impact\n\nRespond with valid JSON only, no other text.",
  "user_prompt": "Analyze the following smart contract for security vulnerabilities.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author Modified from Nouns DAO (https://github.com/withtally/my-nft-dao-project/blob/main/contracts/ERC721Checkpointable.sol)\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (2 years).\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType deposit_type,\n        uint ts\n    );\n\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    event MultiSplit(\n        uint256 indexed _from,\n        uint256[] _newTokenIds,\n        address _sender,\n        uint256[] _amounts,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    event MetadataUpdate(uint256 _tokenId);\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n    event Supply(uint prevSupply, uint supply);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable token;\n    address public voter;\n    address public team;\n    address public artProxy;\n    // address public burnTokenAddress=0x000000000000000000000000000000000000dEaD;\n\n    uint public PRECISISON = 10000;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n    mapping(uint => bool) internal isPartnerVeNFT;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev Current count of token\n    uint internal tokenId;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal iMAXTIME;\n    IHybra public _hybr;\n\n    // Instance of the library's storage struct\n    VotingDelegationLib.Data private cpData;\n\n    VotingBalanceLogic.Data private votingBalanceLogicData;\n\n    /// @notice Contract constructor\n    /// @param token_addr `BLACK` token address\n    constructor(address token_addr, address art_proxy) {\n        token = token_addr;\n        voter = msg.sender;\n        team = msg.sender;\n        artProxy = art_proxy;\n        WEEK = HybraTimeLibrary.WEEK;\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\n        iMAXTIME = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\n\n        votingBalanceLogicData.point_history[0].blk = block.number;\n        votingBalanceLogicData.point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n        _hybr = IHybra(token);\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    modifier notPartnerNFT(uint256 _tokenId) {\n        require(!isPartnerVeNFT[_tokenId], \"PNFT\");\n        _;\n    }\n\n    modifier splitAllowed(uint _from) {\n        require(canSplit[msg.sender] || canSplit[address(0)], \"!SPLIT\");\n        require(attachments[_from] == 0 && !voted[_from], \"ATT\");\n        require(_isApprovedOrOwner(msg.sender, _from), \"NAO\");\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string constant public name = \"veHYBR\";\n    string constant public symbol = \"veHYBR\";\n    string constant public version = \"1.0.0\";\n    uint8 constant public decimals = 18;\n\n    function setTeam(address _team) external {\n        require(msg.sender == team);\n        team = _team;\n    }\n\n    function setArtProxy(address _proxy) external {\n        require(msg.sender == team);\n        artProxy = _proxy;\n        emit BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n    /// @param _tokenId The token ID to modify\n    /// @param _isPartner Whether this should be a partner veNFT\n    function setPartnerVeNFT(uint _tokenId, bool _isPartner) external {\n        require(msg.sender == team, \"NA\");\n        require(idToOwner[_tokenId] != address(0), \"DNE\");\n        isPartnerVeNFT[_tokenId] = _isPartner;\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function tokenURI(uint _tokenId) external view returns (string memory) {\n        require(idToOwner[_tokenId] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        return IVeArtProxy(artProxy)._tokenURI(_tokenId,VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData),_locked.end,uint(int256(_locked.amount)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal idToOwner;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal ownerToNFTokenCount;\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    function ownerToNFTokenCountFn(address owner) public view returns (uint) {\n\n        return ownerToNFTokenCount[owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned p to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view returns (uint) {\n        return _balance(_owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    mapping(uint => uint) public ownership_change;\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint _tokenId) external view returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function approve(address _approved, uint _tokenId) public {\n        address owner = idToOwner[_tokenId];\n        // Throws if `_tokenId` is not a valid NFT\n        require(owner != address(0), \"ZA\");\n        // Throws if `_approved` is the current owner\n        require(_approved != owner, \"IA\");\n        // Check requirements\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll, \"NAO\");\n        // Set the approval\n        idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function setApprovalForAll(address _operator, bool _approved) external {\n        // Throws if `_operator` is the `msg.sender`\n        assert(_operator != msg.sender);\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _clearApproval(address _owner, uint _tokenId) internal {\n        // Throws if `_owner` is not the current owner\n        assert(idToOwner[_tokenId] == _owner);\n        if (idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            idToApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal notPartnerNFT(_tokenId) {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId), \"NAO\");\n\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // auto re-delegate\n        VotingDelegationLib.moveTokenDelegates(cpData, delegates(_from), delegates(_to), _tokenId, ownerOf);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) public {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n\n        if (_isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 response) {\n                if (response != IERC721Receiver(_to).onERC721Received.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal tokenToOwnerIndex;\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) public view returns (uint) {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Add a NFT to an index mapping to a given addressndashushun\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint current_count = _balance(_to);\n\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = current_count;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(address _to, uint _tokenId) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(idToOwner[_tokenId] == address(0));\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_to != address(0));\n        // checkpoint for gov\n        VotingDelegationLib.moveTokenDelegates(cpData, address(0), delegates(_to), _tokenId, ownerOf);\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(_to, _tokenId);\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n        // Delete\n        uint current_count = _balance(_from) - 1;\n        uint current_index = tokenToOwnerIndex[_tokenId];\n\n        if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        delete idToApprovals[_tokenId];\n        // Remove token\n        //_removeTokenFrom(msg.sender, _tokenId);\n        _removeTokenFrom(owner, _tokenId);\n        // checkpoint for gov\n        VotingDelegationLib.moveTokenDelegates(cpData, delegates(owner), address(0), _tokenId, ownerOf);\n\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => IVotingEscrow.LockedBalance) public locked;\n    uint public permanentLockBalance;\n    uint public epoch;\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\n    uint public supply;\n    mapping(address => bool) public canSplit;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\n        uint uepoch = votingBalanceLogicData.user_point_epoch[_tokenId];\n        return votingBalanceLogicData.user_point_history[_tokenId][uepoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function user_point_history(uint _tokenId, uint _idx) external view returns (IVotingEscrow.Point memory) {\n        return votingBalanceLogicData.user_point_history[_tokenId][_idx];\n    }\n\n    function point_history(uint epoch) external view returns (IVotingEscrow.Point memory) {\n        return votingBalanceLogicData.point_history[epoch];\n    }\n\n    function user_point_epoch(uint tokenId) external view returns (uint) {\n        return votingBalanceLogicData.user_point_epoch[tokenId];\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param old_locked Pevious locked amount / end lock time for the user\n    /// @param new_locked New locked amount / end lock time for the user\n    function _checkpoint(\n        uint _tokenId,\n        IVotingEscrow.LockedBalance memory old_locked,\n        IVotingEscrow.LockedBalance memory new_locked\n    ) internal {\n        IVotingEscrow.Point memory u_old;\n        IVotingEscrow.Point memory u_new;\n        int128 old_dslope = 0;\n        int128 new_dslope = 0;\n        uint _epoch = epoch;\n\n        if (_tokenId != 0) {\n            u_new.permanent = 0;\n\n            if(new_locked.isPermanent){\n                u_new.permanent = uint(int256(new_locked.amount));\n            }\n\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\n                u_old.slope = old_locked.amount / iMAXTIME;\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\n            }\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\n                u_new.slope = new_locked.amount / iMAXTIME;\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // old_locked.end can be in the past and in the future\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            old_dslope = slope_changes[old_locked.end];\n            if (new_locked.end != 0) {\n                if (new_locked.end == old_locked.end) {\n                    new_dslope = old_dslope;\n                } else {\n                    new_dslope = slope_changes[new_locked.end];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory last_point = IVotingEscrow.Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number, permanent: 0});\n        if (_epoch > 0) {\n            last_point = votingBalanceLogicData.point_history[_epoch];\n        }\n        uint last_checkpoint = last_point.ts;\n        // initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        IVotingEscrow.Point memory initial_last_point = last_point;\n        uint block_slope = 0; // dblock/dt\n        if (block.timestamp > last_point.ts) {\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                t_i += WEEK;\n                int128 d_slope = 0;\n                if (t_i > block.timestamp) {\n                    t_i = block.timestamp;\n                } else {\n                    d_slope = slope_changes[t_i];\n                }\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\n                last_point.slope += d_slope;\n                if (last_point.bias < 0) {\n                    // This can happen\n                    last_point.bias = 0;\n                }\n                if (last_point.slope < 0) {\n                    // This cannot happen - just in case\n                    last_point.slope = 0;\n                }\n                last_checkpoint = t_i;\n                last_point.ts = t_i;\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\n                _epoch += 1;\n                if (t_i == block.timestamp) {\n                    last_point.blk = block.number;\n                    break;\n                } else {\n                    votingBalanceLogicData.point_history[_epoch] = last_point;\n                }\n            }\n        }\n\n        epoch = _epoch;\n        // Now point_history is filled until t=now\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            last_point.slope += (u_new.slope - u_old.slope);\n            last_point.bias += (u_new.bias - u_old.bias);\n            if (last_point.slope < 0) {\n                last_point.slope = 0;\n            }\n            if (last_point.bias < 0) {\n                last_point.bias = 0;\n            }\n            last_point.permanent = permanentLockBalance;\n        }\n\n        // Record the changed point into history\n        votingBalanceLogicData.point_history[_epoch] = last_point;\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (old_locked.end > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                old_dslope += u_old.slope;\n                if (new_locked.end == old_locked.end) {\n                    old_dslope -= u_new.slope; // It was a new deposit, not extension\n                }\n                slope_changes[old_locked.end] = old_dslope;\n            }\n\n            if (new_locked.end > block.timestamp) {\n                if (new_locked.end > old_locked.end) {\n                    new_dslope -= u_new.slope; // old slope disappeared at this point\n                    slope_changes[new_locked.end] = new_dslope;\n                }\n                // else: we recorded it already in old_dslope\n            }\n            // Now handle user history\n            uint user_epoch = votingBalanceLogicData.user_point_epoch[_tokenId] + 1;\n\n            votingBalanceLogicData.user_point_epoch[_tokenId] = user_epoch;\n            u_new.ts = block.timestamp;\n            u_new.blk = block.number;\n            votingBalanceLogicData.user_point_history[_tokenId][user_epoch] = u_new;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    /// @param locked_balance Previous locked amount / timestamp\n    /// @param deposit_type The type of deposit\n    function _deposit_for(\n        uint _tokenId,\n        uint _value,\n        uint unlock_time,\n        IVotingEscrow.LockedBalance memory locked_balance,\n        DepositType deposit_type\n    ) internal {\n        IVotingEscrow.LockedBalance memory _locked = locked_balance;\n        uint supply_before = supply;\n\n        supply = supply_before + _value;\n        IVotingEscrow.LockedBalance memory old_locked;\n        (old_locked.amount, old_locked.end, old_locked.isPermanent) = (_locked.amount, _locked.end, _locked.isPermanent);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _locked.amount += int128(int256(_value));\n\n        if (unlock_time != 0) {\n            _locked.end = unlock_time;\n        }\n        locked[_tokenId] = _locked;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _checkpoint(_tokenId, old_locked, _locked);\n\n        address from = msg.sender;\n        if (_value != 0) {\n            assert(IERC20(token).transferFrom(from, address(this), _value));\n        }\n\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\n        emit Supply(supply_before, supply_before + _value);\n    }\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external {\n        _checkpoint(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        require(_value > 0, \"ZV\"); // dev: need non-zero value\n        require(_locked.amount > 0, 'ZL');\n        require(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\n\n        if (_locked.isPermanent) permanentLockBalance += _value;\n\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_value > 0, \"ZV\"); // dev: need non-zero value\n        require(unlock_time > block.timestamp && (unlock_time <= block.timestamp + MAXTIME), 'IUT');\n\n        ++tokenId;\n        uint _tokenId = tokenId;\n        _mint(_to, _tokenId);\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        _deposit_for(_tokenId, _value, unlock_time, _locked, DepositType.CREATE_LOCK_TYPE);\n        return _tokenId;\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, msg.sender);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, _to);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        assert(_value > 0); // dev: need non-zero value\n        require(_locked.amount > 0, 'ZL');\n        require(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\n\n        if (_locked.isPermanent) permanentLockBalance += _value;\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\n\n        // poke for the gained voting power\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lock_duration New number of seconds until tokens unlock\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n        require(!_locked.isPermanent, \"!NORM\");\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_locked.end > block.timestamp && _locked.amount > 0, 'EXP||ZV');\n        require(unlock_time > _locked.end && (unlock_time <= block.timestamp + MAXTIME), 'IUT'); // IUT -> invalid unlock time\n\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\n\n        // poke for the gained voting power\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n        require(!_locked.isPermanent, \"!NORM\");\n        require(block.timestamp >= _locked.end, \"!EXP\");\n        uint value = uint(int256(_locked.amount));\n\n        locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint supply_before = supply;\n        supply = supply_before - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, _locked, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supply_before, supply_before - value);\n    }\n\n    function lockPermanent(uint _tokenId) external {\n        address sender = msg.sender;\n        require(_isApprovedOrOwner(sender, _tokenId), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\n        require(!_newLocked.isPermanent, \"!NORM\");\n        require(_newLocked.end > block.timestamp, \"EXP\");\n        require(_newLocked.amount > 0, \"ZV\");\n\n        uint _amount = uint(int256(_newLocked.amount));\n        permanentLockBalance += _amount;\n        _newLocked.end = 0;\n        _newLocked.isPermanent = true;\n        _checkpoint(_tokenId, locked[_tokenId], _newLocked);\n        locked[_tokenId] = _newLocked;\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n        emit LockPermanent(sender, _tokenId, _amount, block.timestamp);\n        emit MetadataUpdate(_tokenId);\n    }\n\n    function unlockPermanent(uint _tokenId) external {\n        address sender = msg.sender;\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\n        IVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\n        require(_newLocked.isPermanent, \"!NORM\");\n        uint _amount = uint(int256(_newLocked.amount));\n        permanentLockBalance -= _amount;\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _newLocked.isPermanent = false;\n\n        _checkpoint(_tokenId, locked[_tokenId], _newLocked);\n        locked[_tokenId] = _newLocked;\n\n        emit UnlockPermanent(sender, _tokenId, _amount, block.timestamp);\n        emit MetadataUpdate(_tokenId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\n        if (ownership_change[_tokenId] == block.number) return 0;\n        return VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n        return VotingBalanceLogic.balanceOfNFT(_tokenId, _t, votingBalanceLogicData);\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n        return VotingBalanceLogic.balanceOfAtNFT(_tokenId, _block, votingBalanceLogicData, epoch);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function totalSupplyAt(uint _block) external view returns (uint) {\n        return VotingBalanceLogic.totalSupplyAt(_block, epoch, votingBalanceLogicData, slope_changes);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        return VotingBalanceLogic.totalSupplyAtT(t, epoch, slope_changes,  votingBalanceLogicData);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => uint) public attachments;\n    mapping(uint => bool) public voted;\n\n    function setVoter(address _voter) external {\n        require(msg.sender == team);\n        voter = _voter;\n    }\n\n    function voting(uint _tokenId) external {\n        require(msg.sender == voter);\n        voted[_tokenId] = true;\n    }\n\n    function abstain(uint _tokenId) external {\n        require(msg.sender == voter, \"NA\");\n        voted[_tokenId] = false;\n    }\n\n    function attach(uint _tokenId) external {\n        require(msg.sender == voter, \"NA\");\n        attachments[_tokenId] = attachments[_tokenId] + 1;\n    }\n\n    function detach(uint _tokenId) external {\n        require(msg.sender == voter, \"NA\");\n        attachments[_tokenId] = attachments[_tokenId] - 1;\n    }\n\n    function merge(uint _from, uint _to) external nonreentrant notPartnerNFT(_from) {\n        require(attachments[_from] == 0 && !voted[_from], \"ATT\");\n        require(_from != _to, \"SAME\");\n        require(_isApprovedOrOwner(msg.sender, _from) &&\n        _isApprovedOrOwner(msg.sender, _to), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _locked0 = locked[_from];\n        IVotingEscrow.LockedBalance memory _locked1 = locked[_to];\n        require(_locked1.end > block.timestamp ||  _locked1.isPermanent,\"EXP||PERM\");\n        require(_locked0.isPermanent ? _locked1.isPermanent : true, \"!MERGE\");\n\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(_from, _locked0, IVotingEscrow.LockedBalance(0, 0, false));\n        _burn(_from);\n\n        IVotingEscrow.LockedBalance memory newLockedTo;\n        newLockedTo.isPermanent = _locked1.isPermanent;\n\n        if (newLockedTo.isPermanent){\n            newLockedTo.amount = _locked1.amount + _locked0.amount;\n            if (!_locked0.isPermanent) {  // Only add if source wasn't already permanent\n                permanentLockBalance += value0;\n            }\n        }else{\n            newLockedTo.amount = _locked1.amount + _locked0.amount;\n            newLockedTo.end = end;\n        }\n\n        //_checkpointDelegatee(_delegates[_to], value0, true);\n        _checkpoint(_to, _locked1, newLockedTo);\n        locked[_to] = newLockedTo;\n\n        if(voted[_to]) {\n            IVoter(voter).poke(_to);\n        }\n        emit Merge(\n            msg.sender,\n            _from,\n            _to,\n            uint(int256(_locked0.amount)),\n            uint(int256(_locked1.amount)),\n            uint(int256(newLockedTo.amount)),\n            newLockedTo.end,\n            block.timestamp\n        );\n        emit MetadataUpdate(_to);\n    }\n\n    // function split(\n    //     uint _from,\n    //     uint _amount\n    // ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256 _tokenId1, uint256 _tokenId2) {\n    //     address owner = idToOwner[_from];\n\n    //     IVotingEscrow.LockedBalance memory newLocked = locked[_from];\n    //     require(newLocked.end > block.timestamp || newLocked.isPermanent, \"EXP\");\n\n    //     int128 _splitAmount = int128(int256(_amount));\n\n    //     require(_splitAmount != 0, \"ZV\");\n    //     require(newLocked.amount > _splitAmount, \"BIGVAL\");\n\n    //     locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n    //     _checkpoint(_from, newLocked, IVotingEscrow.LockedBalance(0, 0, false));\n    //     _burn(_from);\n\n    //     newLocked.amount -= _splitAmount;\n    //     _tokenId1 = _createSplitNFT(owner, newLocked);\n\n    //     newLocked.amount = _splitAmount;\n    //     _tokenId2 = _createSplitNFT(owner, newLocked);\n\n    //     // emit Split(\n    //     //     _from,\n    //     //     _tokenId1,\n    //     //     _tokenId2,\n    //     //     msg.sender,\n    //     //     uint(int256(locked[_tokenId1].amount)),\n    //     //     uint(int256(_splitAmount)),\n    //     //     newLocked.end,\n    //     //     block.timestamp\n    //     // );\n    // }\n\n    /// @notice Split a veNFT into multiple new veNFTs with specified weight distribution\n    /// @param _from The token ID to split\n    /// @param amounts Array of weights for distributing the locked amount\n    /// @return newTokenIds Array of newly created token IDs\n    function multiSplit(\n        uint _from,\n        uint[] memory amounts\n    ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256[] memory newTokenIds) {\n        require(amounts.length >= 2 && amounts.length <= 10, \"MIN2MAX10\");\n\n        address owner = idToOwner[_from];\n\n        IVotingEscrow.LockedBalance memory originalLocked = locked[_from];\n        require(originalLocked.end > block.timestamp || originalLocked.isPermanent, \"EXP\");\n        require(originalLocked.amount > 0, \"ZV\");\n\n        // Calculate total weight\n        uint totalWeight = 0;\n        for(uint i = 0; i < amounts.length; i++) {\n            require(amounts[i] > 0, \"ZW\"); // Zero weight not allowed\n            totalWeight += amounts[i];\n        }\n\n        // Burn the original NFT\n        locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(_from, originalLocked, IVotingEscrow.LockedBalance(0, 0, false));\n        _burn(_from);\n\n        // Create new NFTs with proportional amounts\n        newTokenIds = new uint256[](amounts.length);\n        uint[] memory actualAmounts = new uint[](amounts.length);\n\n        for(uint i = 0; i < amounts.length; i++) {\n            IVotingEscrow.LockedBalance memory newLocked = IVotingEscrow.LockedBalance({\n                amount: int128(int256(uint256(int256(originalLocked.amount)) * amounts[i] / totalWeight)),\n                end: originalLocked.end,\n                isPermanent: originalLocked.isPermanent\n            });\n\n            newTokenIds[i] = _createSplitNFT(owner, newLocked);\n            actualAmounts[i] = uint256(int256(newLocked.amount));\n        }\n\n        emit MultiSplit(\n            _from,\n            newTokenIds,\n            msg.sender,\n            actualAmounts,\n            originalLocked.end,\n            block.timestamp\n        );\n    }\n\n    function _createSplitNFT(address _to, IVotingEscrow.LockedBalance memory _newLocked) private returns (uint256 _tokenId) {\n        _tokenId = ++tokenId;\n        locked[_tokenId] = _newLocked;\n        _checkpoint(_tokenId, IVotingEscrow.LockedBalance(0, 0, false), _newLocked);\n        _mint(_to, _tokenId);\n    }\n\n    function toggleSplit(address _account, bool _bool) external {\n        require(msg.sender == team);\n        canSplit[_account] = _bool;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _delegates;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint) public nonces;\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function delegates(address delegator) public view returns (address) {\n        address current = _delegates[delegator];\n        return current == address(0) ? delegator : current;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(address account) external view returns (uint) {\n        uint32 nCheckpoints = cpData.numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        uint[] storage _tokenIds = cpData.checkpoints[account][nCheckpoints - 1].tokenIds;\n        uint votes = 0;\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint tId = _tokenIds[i];\n            votes = votes + VotingBalanceLogic.balanceOfNFT(tId, block.timestamp, votingBalanceLogicData);\n        }\n        return votes;\n    }\n\n    function getPastVotes(address account, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 _checkIndex = VotingDelegationLib.getPastVotesIndex(cpData, account, timestamp);\n        // Sum votes\n        uint[] storage _tokenIds = cpData.checkpoints[account][_checkIndex].tokenIds;\n        uint votes = 0;\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint tId = _tokenIds[i];\n            // Use the provided input timestamp here to get the right decay\n            votes = votes + VotingBalanceLogic.balanceOfNFT(tId, timestamp,  votingBalanceLogicData);\n        }\n\n        return votes;\n    }\n\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint) {\n        return totalSupplyAtT(timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _delegate(address delegator, address delegatee) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address currentDelegate = delegates(delegator);\n\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        VotingDelegationLib.TokenHelpers memory tokenHelpers = VotingDelegationLib.TokenHelpers({\n            ownerOfFn: ownerOf,\n            ownerToNFTokenCountFn: ownerToNFTokenCountFn,\n            tokenOfOwnerByIndex:tokenOfOwnerByIndex\n        });\n        VotingDelegationLib._moveAllDelegates(cpData, delegator, currentDelegate, delegatee, tokenHelpers);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        if (delegatee == address(0)) delegatee = msg.sender;\n        return _delegate(msg.sender, delegatee);\n    }\n\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(delegatee != msg.sender, \"NA\");\n        require(delegatee != address(0), \"ZA\");\n\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(digest, v, r, s);\n        require(\n            signatory != address(0),\n            \"ZA\"\n        );\n        require(\n            nonce == nonces[signatory]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= expiry,\n            \"EXP\"\n        );\n        return _delegate(signatory, delegatee);\n    }\n\n}\n```\n\nReport ONLY real, exploitable vulnerabilities with concrete attack paths. Do not report informational issues, gas optimizations, or theoretical concerns.\n\n**IMPORTANT: Be concise. Each field has a 100-word maximum.**\n\nRespond with this JSON structure:\n{\n  \"verdict\": \"vulnerable\" or \"safe\",\n  \"confidence\": <float 0.0-1.0>,\n  \"vulnerabilities\": [\n    {\n      \"type\": \"<vulnerability type, e.g., reentrancy, access_control, integer_overflow>\",\n      \"severity\": \"critical\" or \"high\" or \"medium\" or \"low\",\n      \"location\": \"<function name or line description>\",\n      \"explanation\": \"<max 100 words: what is vulnerable and why it's exploitable>\",\n      \"attack_scenario\": \"<max 100 words: specific steps to exploit this>\",\n      \"suggested_fix\": \"<max 100 words: specific code changes to fix this>\"\n    }\n  ],\n  \"overall_explanation\": \"<max 100 words: summary of the security analysis>\"\n}\n\nIf the contract is safe or has no exploitable vulnerabilities, return an empty vulnerabilities array and explain why it's secure.",
  "raw_response": "{\n  \"verdict\": \"vulnerable\",\n  \"confidence\": 0.9,\n  \"vulnerabilities\": [\n    {\n      \"type\": \"arithmetic\",\n      \"severity\": \"high\",\n      \"location\": \"multiSplit\",\n      \"explanation\": \"MultiSplit calculates new locked amounts using integer division, truncating remainders. If original amount isn't evenly divisible, sum of new amounts is less than original. Original NFT is burned without updating supply, leaving remainder tokens stuck in the contract, unassignable and unwithdrawable, causing permanent loss of user funds.\",\n      \"attack_scenario\": \"1. User locks 3 tokens in NFT #1. 2. Calls multiSplit(#1, [1,1]), totalWeight=2. 3. New amounts: 3*1/2=1 each, sum=2. 4. #1 burned. 5. New NFTs #2 and #3 minted with 1 each. 6. 1 token stuck. User withdraws 2 total, loses 1.\",\n      \"suggested_fix\": \"Calculate base amounts with division. Compute remainder = original.amount - sum(base amounts). Add remainder to last newLocked.amount. Ensure sum(new amounts) == original.amount to prevent loss. Revert if impossible.\"\n    }\n  ],\n  \"overall_explanation\": \"The contract is mostly secure with reentrancy guards, access controls, and overflow protection in Solidity 0.8. However, multiSplit has an arithmetic flaw causing precision loss and stuck funds. No other concrete exploitable vulnerabilities like reentrancy or unauthorized access found.\"\n}",
  "tokens": {
    "input": 13868,
    "output": 7739,
    "total": 21607
  },
  "cost_usd": 0.15768900000000002,
  "latency_ms": 233576.12279200112,
  "error": null,
  "prediction": {
    "verdict": "vulnerable",
    "confidence": 0.9,
    "vulnerabilities": [
      {
        "type": "arithmetic",
        "severity": "high",
        "location": "multiSplit",
        "explanation": "MultiSplit calculates new locked amounts using integer division, truncating remainders. If original amount isn't evenly divisible, sum of new amounts is less than original. Original NFT is burned without updating supply, leaving remainder tokens stuck in the contract, unassignable and unwithdrawable, causing permanent loss of user funds.",
        "attack_scenario": "1. User locks 3 tokens in NFT #1. 2. Calls multiSplit(#1, [1,1]), totalWeight=2. 3. New amounts: 3*1/2=1 each, sum=2. 4. #1 burned. 5. New NFTs #2 and #3 minted with 1 each. 6. 1 token stuck. User withdraws 2 total, loses 1.",
        "suggested_fix": "Calculate base amounts with division. Compute remainder = original.amount - sum(base amounts). Add remainder to last newLocked.amount. Ensure sum(new amounts) == original.amount to prevent loss. Revert if impossible."
      }
    ],
    "overall_explanation": "The contract is mostly secure with reentrancy guards, access controls, and overflow protection in Solidity 0.8. However, multiSplit has an arithmetic flaw causing precision loss and stuck funds. No other concrete exploitable vulnerabilities like reentrancy or unauthorized access found.",
    "parse_success": true,
    "parse_errors": []
  }
}