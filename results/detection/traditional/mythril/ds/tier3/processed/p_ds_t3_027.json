{
  "sample_id": "ds_t3_027",
  "tier": "tier3",
  "tool": "mythril",
  "tool_version": "0.24.8",
  "solc_version": "0.4.11",
  "timestamp": "2026-01-04T09:08:37.862321",
  "success": true,
  "error": null,
  "execution_time_ms": 220246.2339401245,
  "used_reduced_depth": true,
  "processing": {
    "processed_at": "2026-01-04T12:56:07.304159",
    "original_finding_count": 11,
    "filtered_finding_count": 11,
    "filter_breakdown": {
      "kept_high_medium": 10,
      "kept_low_mapped": 1,
      "filtered_excluded_swc": 0,
      "filtered_low_unmapped": 0
    },
    "filters_applied": [
      "High/Medium severity: keep all",
      "Low severity: keep only if mapped to vulnerability type",
      "Excluded SWC IDs: {'108', '103'}"
    ]
  },
  "findings": [
    {
      "original_index": 0,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "SafeMath",
      "function": "fallback",
      "lineno": 38,
      "code": "contract SafeMath {\n    function safeMul(uint a, uint b) internal returns (uint) {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint a, uint b) internal returns (uint) {\n        assert(b > 0);\n        uint c = a / b;\n        assert(a == b * c + (a % b));\n        return c;\n    }\n\n    function safeSub(uint a, uint b) internal returns (uint) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint a, uint b) internal returns (uint) {\n        uint c = a + b;\n        assert(c >= a && c >= b);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function assert(bool assertion) internal {\n        if (!assertion) {\n            throw;\n        }\n    }\n}"
    },
    {
      "original_index": 1,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "SafeMath",
      "function": "constructor",
      "lineno": 38,
      "code": "contract SafeMath {\n    function safeMul(uint a, uint b) internal returns (uint) {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint a, uint b) internal returns (uint) {\n        assert(b > 0);\n        uint c = a / b;\n        assert(a == b * c + (a % b));\n        return c;\n    }\n\n    function safeSub(uint a, uint b) internal returns (uint) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint a, uint b) internal returns (uint) {\n        uint c = a + b;\n        assert(c >= a && c >= b);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function assert(bool assertion) internal {\n        if (!assertion) {\n            throw;\n        }\n    }\n}"
    },
    {
      "original_index": 2,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "StandardToken",
      "function": "constructor",
      "lineno": 86,
      "code": "contract StandardToken is ERC20, SafeMath {\n    /* Token supply got increased and a new owner received these tokens */\n    event Minted(address receiver, uint amount);\n\n    /* Actual balances of token holders */\n    mapping(address => uint) balances;\n    // what exaclt ether was sent\n    mapping(address => uint) balancesRAW;\n    /* approve() allowances */\n    mapping(address => mapping(address => uint)) allowed;\n\n    /* Interface declaration */\n    function isToken() public constant returns (bool weAre) {\n        return true;\n    }\n\n    function transfer(address _to, uint _value) returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _value\n    ) returns (bool success) {\n        uint _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(_allowance, _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool success) {\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint remaining) {\n        return allowed[_owner][_spender];\n    }\n}"
    },
    {
      "original_index": 3,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "StandardToken",
      "function": "fallback",
      "lineno": 86,
      "code": "contract StandardToken is ERC20, SafeMath {\n    /* Token supply got increased and a new owner received these tokens */\n    event Minted(address receiver, uint amount);\n\n    /* Actual balances of token holders */\n    mapping(address => uint) balances;\n    // what exaclt ether was sent\n    mapping(address => uint) balancesRAW;\n    /* approve() allowances */\n    mapping(address => mapping(address => uint)) allowed;\n\n    /* Interface declaration */\n    function isToken() public constant returns (bool weAre) {\n        return true;\n    }\n\n    function transfer(address _to, uint _value) returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _value\n    ) returns (bool success) {\n        uint _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(_allowance, _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool success) {\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint remaining) {\n        return allowed[_owner][_spender];\n    }\n}"
    },
    {
      "original_index": 4,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "daoPOLSKAtokens",
      "function": "constructor",
      "lineno": 144,
      "code": "contract daoPOLSKAtokens {\n    string public name = \"DAO POLSKA TOKEN version 1\";\n    string public symbol = \"DPL\";\n    uint8 public constant decimals = 18; // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives\n    address public owner;\n    address public migrationMaster;\n    // The current total token supply.\n\n    uint256 public otherchainstotalsupply = 1.0 ether;\n    uint256 public supplylimit = 10000.0 ether;\n    //totalSupply\n    uint256 public totalSupply = 0.0 ether;\n    //chains:\n    address public Chain1 = 0x0;\n    address public Chain2 = 0x0;\n    address public Chain3 = 0x0;\n    address public Chain4 = 0x0;\n\n    address public migrationAgent = 0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public totalMigrated;\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    struct sendTokenAway {\n        StandardToken coinContract;\n        uint amount;\n        address recipient;\n    }\n    mapping(uint => sendTokenAway) transfers;\n    uint numTransfers = 0;\n\n    mapping(address => uint256) balances;\n    mapping(address => uint256) balancesRAW;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    event UpdatedTokenInformation(string newName, string newSymbol);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event receivedEther(address indexed _from, uint256 _value);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n    //tokenCreationCap\n    bool public supplylimitset = false;\n    bool public otherchainstotalset = false;\n\n    function daoPOLSKAtokens() {\n        owner = msg.sender;\n        migrationMaster = msg.sender;\n    }\n\n    function setSupply(uint256 supplyLOCKER) public {\n        if (msg.sender != owner) {\n            throw;\n        }\n        if (supplylimitset != false) {\n            throw;\n        }\n        supplylimitset = true;\n\n        supplylimit = supplyLOCKER ** uint256(decimals);\n        //balances[owner]=supplylimit;\n    }\n\n    function setotherchainstotalsupply(uint256 supplyLOCKER) public {\n        if (msg.sender != owner) {\n            throw;\n        }\n        if (supplylimitset != false) {\n            throw;\n        }\n\n        otherchainstotalset = true;\n        otherchainstotalsupply = supplyLOCKER ** uint256(decimals);\n    }\n\n    function approveAndCall(\n        address _spender,\n        uint256 _value,\n        bytes _extraData\n    ) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value); // Check if the sender has enough\n        balances[msg.sender] -= _value; // Subtract from the sender\n        totalSupply -= _value; // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(\n        address _from,\n        uint256 _value\n    ) public returns (bool success) {\n        require(balances[_from] >= _value); // Check if the targeted balance is enough\n        require(_value <= allowed[_from][msg.sender]); // Check allowance\n        balances[_from] -= _value; // Subtract from the targeted balance\n        allowed[_from][msg.sender] -= _value; // Subtract from the sender's allowance\n        totalSupply -= _value; // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (\n            balances[msg.sender] >= _value &&\n            balances[_to] + _value > balances[_to]\n        ) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n        if (\n            balances[_from] >= _value &&\n            allowed[_from][msg.sender] >= _value &&\n            balances[_to] + _value > balances[_to]\n        ) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function() public payable {\n        if (funding) {\n            receivedEther(msg.sender, msg.value);\n            balances[msg.sender] = balances[msg.sender] + msg.value;\n        } else throw;\n    }\n\n    function setTokenInformation(string _name, string _symbol) {\n        if (msg.sender != owner) {\n            throw;\n        }\n        name = _name;\n        symbol = _symbol;\n\n        UpdatedTokenInformation(name, symbol);\n    }\n\n    function setChainsAddresses(address chainAd, int chainnumber) {\n        if (msg.sender != owner) {\n            throw;\n        }\n        if (chainnumber == 1) {\n            Chain1 = chainAd;\n        }\n        if (chainnumber == 2) {\n            Chain2 = chainAd;\n        }\n        if (chainnumber == 3) {\n            Chain3 = chainAd;\n        }\n        if (chainnumber == 4) {\n            Chain4 = chainAd;\n        }\n    }\n\n    function DAOPolskaTokenICOregulations() external returns (string wow) {\n        return\n            \"Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules\";\n    }\n\n    function sendTokenAw(\n        address StandardTokenAddress,\n        address receiver,\n        uint amount\n    ) {\n        if (msg.sender != owner) {\n            throw;\n        }\n        sendTokenAway t = transfers[numTransfers];\n        t.coinContract = StandardToken(StandardTokenAddress);\n        t.amount = amount;\n        t.recipient = receiver;\n        t.coinContract.transfer(receiver, amount);\n        numTransfers++;\n    }\n\n    // Crowdfunding:\n    uint public tokenCreationRate = 1000;\n    uint public bonusCreationRate = 1000;\n    uint public CreationRate = 1761;\n    uint256 public constant oneweek = 36000;\n    uint256 public fundingEndBlock = 5433616;\n    bool public funding = true;\n    bool public refundstate = false;\n    bool public migratestate = false;\n\n    function createDaoPOLSKAtokens(address holder) payable {\n        if (!funding) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n        // check the maximum token creation cap\n        if (msg.value > (supplylimit - totalSupply) / CreationRate) throw;\n\n        //bonus structure\n        // in early stage there is about 100% more details in ico regulations on website\n        // price and converstion rate in tabled to PLN not ether, and is updated daily\n\n        var numTokensRAW = msg.value;\n\n        var numTokens = msg.value * CreationRate;\n        totalSupply += numTokens;\n\n        // Assign new tokens to the sender\n        balances[holder] += numTokens;\n        balancesRAW[holder] += numTokensRAW;\n        // Log token creation event\n        Transfer(0, holder, numTokens);\n\n        // Create additional Dao Tokens for the community and developers around 12%\n        uint256 percentOfTotal = 12;\n        uint256 additionalTokens = (numTokens * percentOfTotal) / (100);\n\n        totalSupply += additionalTokens;\n\n        balances[migrationMaster] += additionalTokens;\n        Transfer(0, migrationMaster, additionalTokens);\n    }\n\n    function setBonusCreationRate(uint newRate) {\n        if (msg.sender == owner) {\n            bonusCreationRate = newRate;\n            CreationRate = tokenCreationRate + bonusCreationRate;\n        }\n    }\n\n    function FundsTransfer() external {\n        if (funding == true) throw;\n        if (!owner.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n        if (msg.sender != owner) throw;\n        owner.send(this.balance - SubX);\n    }\n\n    function turnrefund() external {\n        if (msg.sender != owner) throw;\n        refundstate = !refundstate;\n    }\n\n    function fundingState() external {\n        if (msg.sender != owner) throw;\n        funding = !funding;\n    }\n\n    function turnmigrate() external {\n        if (msg.sender != migrationMaster) throw;\n        migratestate = !migratestate;\n    }\n\n    // notice Finalize crowdfunding clossing funding options\n\n    function finalize() external {\n        if (block.number <= fundingEndBlock + 8 * oneweek) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n        refundstate = !refundstate;\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender == owner) owner.send(this.balance);\n    }\n\n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (migratestate) throw;\n\n        // Validate input value.\n        if (_value == 0) throw;\n        if (_value > balances[msg.sender]) throw;\n\n        balances[msg.sender] -= _value;\n        totalSupply -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    function refundTRA() external {\n        // Abort if not in Funding Failure state.\n        if (funding) throw;\n        if (!refundstate) throw;\n\n        var DAOPLTokenValue = balances[msg.sender];\n        var ETHValue = balancesRAW[msg.sender];\n        if (ETHValue == 0) throw;\n        balancesRAW[msg.sender] = 0;\n        totalSupply -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n    }\n\n    function preICOregulations() external returns (string wow) {\n        return\n            \"Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules\";\n    }\n}"
    },
    {
      "original_index": 5,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "daoPOLSKAtokens",
      "function": "name()",
      "lineno": 145,
      "code": "string public name = \"DAO POLSKA TOKEN version 1\""
    },
    {
      "original_index": 6,
      "title": "Integer Arithmetic Bugs",
      "swc_id": "101",
      "severity": "High",
      "mapped_vuln_type": "integer_issues",
      "description": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. ",
      "contract": "daoPOLSKAtokens",
      "function": "setotherchainstotalsupply(uint256)",
      "lineno": 225,
      "code": "supplyLOCKER ** uint256(decimals)"
    },
    {
      "original_index": 7,
      "title": "Integer Arithmetic Bugs",
      "swc_id": "101",
      "severity": "High",
      "mapped_vuln_type": "integer_issues",
      "description": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. ",
      "contract": "daoPOLSKAtokens",
      "function": "setSupply(uint256)",
      "lineno": 212,
      "code": "supplyLOCKER ** uint256(decimals)"
    },
    {
      "original_index": 8,
      "title": "Integer Arithmetic Bugs",
      "swc_id": "101",
      "severity": "High",
      "mapped_vuln_type": "integer_issues",
      "description": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. ",
      "contract": "daoPOLSKAtokens",
      "function": "setBonusCreationRate(uint256)",
      "lineno": 414,
      "code": "tokenCreationRate + bonusCreationRate"
    },
    {
      "original_index": 9,
      "title": "Unchecked return value from external call.",
      "swc_id": "104",
      "severity": "Medium",
      "mapped_vuln_type": "unchecked_return",
      "description": "The return value of a message call is not checked.\nExternal calls return a boolean value. If the callee halts with an exception, 'false' is returned and execution continues in the caller. The caller should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls in require() so the transaction is reverted if the call fails.",
      "contract": "daoPOLSKAtokens",
      "function": "PartialFundsTransfer(uint256)",
      "lineno": 425,
      "code": "owner.send(this.balance - SubX)"
    },
    {
      "original_index": 10,
      "title": "Dependence on predictable environment variable",
      "swc_id": "120",
      "severity": "Low",
      "mapped_vuln_type": "weak_randomness",
      "description": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.",
      "contract": "daoPOLSKAtokens",
      "function": "finalize()",
      "lineno": 446,
      "code": "if (block.number <= fundingEndBlock + 8 * oneweek) throw"
    }
  ]
}