{
  "sample_id": "ds_t2_081",
  "tier": "tier2",
  "tool": "mythril",
  "tool_version": "0.24.8",
  "solc_version": "0.4.11",
  "timestamp": "2026-01-04T01:05:03.026158",
  "success": true,
  "error": null,
  "execution_time_ms": 46735.60190200806,
  "used_reduced_depth": true,
  "processing": {
    "processed_at": "2026-01-04T12:56:07.107003",
    "original_finding_count": 5,
    "filtered_finding_count": 5,
    "filter_breakdown": {
      "kept_high_medium": 4,
      "kept_low_mapped": 1,
      "filtered_excluded_swc": 0,
      "filtered_low_unmapped": 0
    },
    "filters_applied": [
      "High/Medium severity: keep all",
      "Low severity: keep only if mapped to vulnerability type",
      "Excluded SWC IDs: {'103', '108'}"
    ]
  },
  "findings": [
    {
      "original_index": 0,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "Lotto",
      "function": "constructor",
      "lineno": 3,
      "code": "contract Lotto {\n    uint public constant blocksPerRound = 6800;\n    // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n    uint public constant ticketPrice = 100000000000000000;\n    // the cost of each ticket is .1 ether.\n\n    uint public constant blockReward = 5000000000000000000;\n\n    function getBlocksPerRound() constant returns (uint) {\n        return blocksPerRound;\n    }\n\n    function getTicketPrice() constant returns (uint) {\n        return ticketPrice;\n    }\n\n    //accessors for constants\n\n    struct Round {\n        address[] buyers;\n        uint pot;\n        uint ticketsCount;\n        mapping(uint => bool) isCashed;\n        mapping(address => uint) ticketsCountByBuyer;\n    }\n    mapping(uint => Round) rounds;\n\n    //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n    function getRoundIndex() constant returns (uint) {\n        //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n        return block.number / blocksPerRound;\n    }\n\n    function getIsCashed(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (bool) {\n        //Determine if a given.\n\n        return rounds[roundIndex].isCashed[subpotIndex];\n    }\n\n    function calculateWinner(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (address) {\n        //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n        var decisionBlockNumber = getDecisionBlockNumber(\n            roundIndex,\n            subpotIndex\n        );\n\n        if (decisionBlockNumber > block.number) return;\n        //We can't decided the winner if the round isn't over yet\n\n        var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n        var winningTicketIndex = decisionBlockHash %\n            rounds[roundIndex].ticketsCount;\n        //We perform a modulus of the blockhash to determine the winner\n\n        var ticketIndex = uint256(0);\n\n        for (\n            var buyerIndex = 0;\n            buyerIndex < rounds[roundIndex].buyers.length;\n            buyerIndex++\n        ) {\n            var buyer = rounds[roundIndex].buyers[buyerIndex];\n            ticketIndex += rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n            if (ticketIndex > winningTicketIndex) {\n                return buyer;\n            }\n        }\n    }\n\n    function getDecisionBlockNumber(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (uint) {\n        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;\n    }\n\n    function getSubpotsCount(uint roundIndex) constant returns (uint) {\n        var subpotsCount = rounds[roundIndex].pot / blockReward;\n\n        if (rounds[roundIndex].pot % blockReward > 0) subpotsCount++;\n\n        return subpotsCount;\n    }\n\n    function getSubpot(uint roundIndex) constant returns (uint) {\n        return rounds[roundIndex].pot / getSubpotsCount(roundIndex);\n    }\n\n    function cash(uint roundIndex, uint subpotIndex) {\n        var subpotsCount = getSubpotsCount(roundIndex);\n\n        if (subpotIndex >= subpotsCount) return;\n\n        var decisionBlockNumber = getDecisionBlockNumber(\n            roundIndex,\n            subpotIndex\n        );\n\n        if (decisionBlockNumber > block.number) return;\n\n        if (rounds[roundIndex].isCashed[subpotIndex]) return;\n        //Subpots can only be cashed once. This is to prevent double payouts\n\n        var winner = calculateWinner(roundIndex, subpotIndex);\n        var subpot = getSubpot(roundIndex);\n\n        winner.send(subpot);\n\n        rounds[roundIndex].isCashed[subpotIndex] = true;\n        //Mark the round as cashed\n    }\n\n    function getHashOfBlock(uint blockIndex) constant returns (uint) {\n        return uint(block.blockhash(blockIndex));\n    }\n\n    function getBuyers(\n        uint roundIndex,\n        address buyer\n    ) constant returns (address[]) {\n        return rounds[roundIndex].buyers;\n    }\n\n    function getTicketsCountByBuyer(\n        uint roundIndex,\n        address buyer\n    ) constant returns (uint) {\n        return rounds[roundIndex].ticketsCountByBuyer[buyer];\n    }\n\n    function getPot(uint roundIndex) constant returns (uint) {\n        return rounds[roundIndex].pot;\n    }\n\n    function() {\n        //this is the function that gets called when people send money to the contract.\n\n        var roundIndex = getRoundIndex();\n        var value = msg.value - (msg.value % ticketPrice);\n\n        if (value == 0) return;\n\n        if (value < msg.value) {\n            msg.sender.send(msg.value - value);\n        }\n        //no partial tickets, send a partial refund\n\n        var ticketsCount = value / ticketPrice;\n        rounds[roundIndex].ticketsCount += ticketsCount;\n\n        if (rounds[roundIndex].ticketsCountByBuyer[msg.sender] == 0) {\n            var buyersLength = rounds[roundIndex].buyers.length++;\n            rounds[roundIndex].buyers[buyersLength] = msg.sender;\n        }\n\n        rounds[roundIndex].ticketsCountByBuyer[msg.sender] += ticketsCount;\n        rounds[roundIndex].ticketsCount += ticketsCount;\n        //keep track of the total tickets\n\n        rounds[roundIndex].pot += value;\n        //keep track of the total pot\n    }\n}"
    },
    {
      "original_index": 1,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "Lotto",
      "function": "fallback",
      "lineno": 3,
      "code": "contract Lotto {\n    uint public constant blocksPerRound = 6800;\n    // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n    uint public constant ticketPrice = 100000000000000000;\n    // the cost of each ticket is .1 ether.\n\n    uint public constant blockReward = 5000000000000000000;\n\n    function getBlocksPerRound() constant returns (uint) {\n        return blocksPerRound;\n    }\n\n    function getTicketPrice() constant returns (uint) {\n        return ticketPrice;\n    }\n\n    //accessors for constants\n\n    struct Round {\n        address[] buyers;\n        uint pot;\n        uint ticketsCount;\n        mapping(uint => bool) isCashed;\n        mapping(address => uint) ticketsCountByBuyer;\n    }\n    mapping(uint => Round) rounds;\n\n    //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n    function getRoundIndex() constant returns (uint) {\n        //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n        return block.number / blocksPerRound;\n    }\n\n    function getIsCashed(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (bool) {\n        //Determine if a given.\n\n        return rounds[roundIndex].isCashed[subpotIndex];\n    }\n\n    function calculateWinner(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (address) {\n        //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n        var decisionBlockNumber = getDecisionBlockNumber(\n            roundIndex,\n            subpotIndex\n        );\n\n        if (decisionBlockNumber > block.number) return;\n        //We can't decided the winner if the round isn't over yet\n\n        var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n        var winningTicketIndex = decisionBlockHash %\n            rounds[roundIndex].ticketsCount;\n        //We perform a modulus of the blockhash to determine the winner\n\n        var ticketIndex = uint256(0);\n\n        for (\n            var buyerIndex = 0;\n            buyerIndex < rounds[roundIndex].buyers.length;\n            buyerIndex++\n        ) {\n            var buyer = rounds[roundIndex].buyers[buyerIndex];\n            ticketIndex += rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n            if (ticketIndex > winningTicketIndex) {\n                return buyer;\n            }\n        }\n    }\n\n    function getDecisionBlockNumber(\n        uint roundIndex,\n        uint subpotIndex\n    ) constant returns (uint) {\n        return ((roundIndex + 1) * blocksPerRound) + subpotIndex;\n    }\n\n    function getSubpotsCount(uint roundIndex) constant returns (uint) {\n        var subpotsCount = rounds[roundIndex].pot / blockReward;\n\n        if (rounds[roundIndex].pot % blockReward > 0) subpotsCount++;\n\n        return subpotsCount;\n    }\n\n    function getSubpot(uint roundIndex) constant returns (uint) {\n        return rounds[roundIndex].pot / getSubpotsCount(roundIndex);\n    }\n\n    function cash(uint roundIndex, uint subpotIndex) {\n        var subpotsCount = getSubpotsCount(roundIndex);\n\n        if (subpotIndex >= subpotsCount) return;\n\n        var decisionBlockNumber = getDecisionBlockNumber(\n            roundIndex,\n            subpotIndex\n        );\n\n        if (decisionBlockNumber > block.number) return;\n\n        if (rounds[roundIndex].isCashed[subpotIndex]) return;\n        //Subpots can only be cashed once. This is to prevent double payouts\n\n        var winner = calculateWinner(roundIndex, subpotIndex);\n        var subpot = getSubpot(roundIndex);\n\n        winner.send(subpot);\n\n        rounds[roundIndex].isCashed[subpotIndex] = true;\n        //Mark the round as cashed\n    }\n\n    function getHashOfBlock(uint blockIndex) constant returns (uint) {\n        return uint(block.blockhash(blockIndex));\n    }\n\n    function getBuyers(\n        uint roundIndex,\n        address buyer\n    ) constant returns (address[]) {\n        return rounds[roundIndex].buyers;\n    }\n\n    function getTicketsCountByBuyer(\n        uint roundIndex,\n        address buyer\n    ) constant returns (uint) {\n        return rounds[roundIndex].ticketsCountByBuyer[buyer];\n    }\n\n    function getPot(uint roundIndex) constant returns (uint) {\n        return rounds[roundIndex].pot;\n    }\n\n    function() {\n        //this is the function that gets called when people send money to the contract.\n\n        var roundIndex = getRoundIndex();\n        var value = msg.value - (msg.value % ticketPrice);\n\n        if (value == 0) return;\n\n        if (value < msg.value) {\n            msg.sender.send(msg.value - value);\n        }\n        //no partial tickets, send a partial refund\n\n        var ticketsCount = value / ticketPrice;\n        rounds[roundIndex].ticketsCount += ticketsCount;\n\n        if (rounds[roundIndex].ticketsCountByBuyer[msg.sender] == 0) {\n            var buyersLength = rounds[roundIndex].buyers.length++;\n            rounds[roundIndex].buyers[buyersLength] = msg.sender;\n        }\n\n        rounds[roundIndex].ticketsCountByBuyer[msg.sender] += ticketsCount;\n        rounds[roundIndex].ticketsCount += ticketsCount;\n        //keep track of the total tickets\n\n        rounds[roundIndex].pot += value;\n        //keep track of the total pot\n    }\n}"
    },
    {
      "original_index": 2,
      "title": "Dependence on predictable environment variable",
      "swc_id": "120",
      "severity": "Low",
      "mapped_vuln_type": "weak_randomness",
      "description": "A control flow decision is made based on The block.number environment variable.\nThe block.number environment variable is used to determine a control flow decision. Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and can be manipulated by a malicious miner. Also keep in mind that attackers know hashes of earlier blocks. Don't use any of those environment variables as sources of randomness and be aware that use of these variables introduces a certain level of trust into miners.",
      "contract": "Lotto",
      "function": "calculateWinner(uint256,uint256)",
      "lineno": 59,
      "code": "if (decisionBlockNumber > block.number) return;"
    },
    {
      "original_index": 3,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "Lotto",
      "function": "calculateWinner(uint256,uint256)",
      "lineno": 126,
      "code": "function getHashOfBlock(uint blockIndex) constant returns (uint) {\n        return uint(block.blockhash(blockIndex));\n    }"
    },
    {
      "original_index": 4,
      "title": "Exception State",
      "swc_id": "110",
      "severity": "Medium",
      "mapped_vuln_type": "logic_error",
      "description": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).",
      "contract": "Lotto",
      "function": "getSubpot(uint256)",
      "lineno": 90,
      "code": "function getSubpotsCount(uint roundIndex) constant returns (uint) {\n        var subpotsCount = rounds[roundIndex].pot / blockReward;\n\n        if (rounds[roundIndex].pot % blockReward > 0) subpotsCount++;\n\n        return subpotsCount;\n    }"
    }
  ]
}