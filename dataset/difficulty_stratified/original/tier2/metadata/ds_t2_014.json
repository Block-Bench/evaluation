{
  "id": "ds_t2_014",
  "original_id": "defivulnlabs_overflow2",
  "source_dataset": "DeFiVulnLabs",
  "language": "solidity",
  "chain": "evm",
  "file_name": "Overflow2.sol",
  "vulnerable_function": "multiple",
  "vulnerable_lines": [],
  "vulnerability_type": "integer_issues",
  "original_category": null,
  "severity": "high",
  "difficulty_tier": 2,
  "description": "This contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air",
  "fix_description": "1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.",
  "is_vulnerable": true,
  "context_level": "single_file",
  "original_source_path": "src/test/Overflow2.sol",
  "source_url": null,
  "references": [],
  "framework": "foundry",
  "contract_file": "contracts/ds_t2_014.sol",
  "subset": "annotated",
  "original_subset": "difficulty_stratified",
  "original_ds_id": "ds_101"
}
