schema_version: "1.0"
sample_id: "ms_tc_001"
vulnerability_type: "improper_initialization"
vulnerable_lines: [53]

# Full line coverage for scoring. UNRELATED items are batched for efficiency.
# Detailed rationales only for security-relevant code acts.

code_acts:

  # ============================================
  # SECURITY-RELEVANT CODE ACTS (detailed)
  # ============================================

  - id: "CA1"
    type: "DECLARATION"
    lines: [18]
    code: "bytes32 public acceptedRoot;"
    security_function: "BENIGN"
    rationale: "State variable declaration. In Solidity, bytes32 defaults to 0x00...00. This is an enabling condition - the zero default value is harmless if proper validation rejects zero roots. The vulnerability is in the validation logic (CA6), not in Solidity's default initialization behavior."

  - id: "CA2"
    type: "INITIALIZATION"
    lines: [28, 29, 30]
    code: |
      constructor(address _bridgeRouter) {
          bridgeRouter = _bridgeRouter;
      }
    security_function: "BENIGN"
    rationale: "Constructor initializes bridgeRouter. While acceptedRoot could have been initialized here as a defensive measure, this is a missed mitigation opportunity, not the vulnerability itself. The root cause is the validation logic accepting zero roots (CA6)."

  - id: "CA3"
    type: "COMPUTATION"
    lines: [42]
    code: "bytes32 messageHash = keccak256(_message);"
    security_function: "BENIGN"
    rationale: "Computes keccak256 hash of the message for replay protection. Correctly implemented hash computation from memory parameter."

  - id: "CA4"
    type: "INPUT_VAL"
    lines: [45, 46, 47, 48]
    code: |
      require(
          messages[messageHash] != MessageStatus.Processed,
          "Already processed"
      );
    security_function: "BENIGN"
    rationale: "Replay protection that prevents the same message from being processed twice. Correctly implemented."

  - id: "CA5"
    type: "CTRL_FLOW"
    lines: [52]
    code: "bytes32 root = _messageRoot(_message);"
    security_function: "BENIGN"
    rationale: "Calls internal function to compute message root. This is standard control flow - the vulnerability is not in calling this function but in the validation that accepts zero roots."

  - id: "CA6"
    type: "INPUT_VAL"
    lines: [53]
    code: 'require(root == acceptedRoot, "Invalid root");'
    security_function: "ROOT_CAUSE"
    rationale: "The critical validation check. ROOT_CAUSE because it passes when both root and acceptedRoot are zero (0x00 == 0x00). The check is syntactically correct but semantically broken due to uninitialized state."

  - id: "CA7"
    type: "STATE_MOD"
    lines: [56]
    code: "messages[messageHash] = MessageStatus.Processed;"
    security_function: "BENIGN"
    rationale: "Marks message as processed BEFORE external call, following CEI pattern. Correctly prevents reentrancy."

  - id: "CA8"
    type: "EXT_CALL"
    lines: [59]
    code: "(bool routerSuccess, ) = bridgeRouter.call(_message);"
    security_function: "BENIGN"
    rationale: "External call that forwards message to bridgeRouter. This is the impact execution path where funds are transferred, but the exploit has already succeeded at CA6. The call itself is correctly implemented."

  - id: "CA9"
    type: "EVENT_EMIT"
    lines: [61]
    code: "emit MessageProcessed(messageHash, routerSuccess);"
    security_function: "BENIGN"
    rationale: "Event emission for logging. No state modification, writes to transaction logs only."

  - id: "CA10"
    type: "CTRL_FLOW"
    lines: [62]
    code: "return routerSuccess;"
    security_function: "BENIGN"
    rationale: "Return statement propagating router call result."

  - id: "CA11"
    type: "CTRL_FLOW"
    lines: [76, 77, 78]
    code: |
      if (_message.length > 32 && uint256(bytes32(_message)) == 0) {
          return bytes32(0);
      }
    security_function: "BENIGN"
    rationale: "Conditional in _messageRoot that returns bytes32(0) for messages starting with 32 zero bytes. While this enables crafting messages with zero roots, the vulnerability is in the validation accepting zero - proper validation would reject zero roots regardless of how they were computed."

  - id: "CA12"
    type: "COMPUTATION"
    lines: [80]
    code: "return keccak256(_message);"
    security_function: "BENIGN"
    rationale: "Default return path in _messageRoot computing keccak256 hash. Correctly implemented."

  - id: "CA13"
    type: "ACCESS_CTRL"
    lines: [83, 84, 85]
    code: |
      function setAcceptedRoot(bytes32 _newRoot) external {
          acceptedRoot = _newRoot;
      }
    security_function: "SECONDARY_VULN"
    rationale: "This function allows ANYONE to set acceptedRoot - no onlyOwner modifier. This is a REAL vulnerability (CWE-284: Improper Access Control) but NOT the documented vulnerability. The Nomad exploit used the UNINITIALIZED zero value, not this function."

  # ============================================
  # BATCHED UNRELATED CODE ACTS (for scoring)
  # ============================================

  - id: "CA_DIRECTIVES"
    type: "DIRECTIVE"
    lines: [1, 2]
    security_function: "UNRELATED"
    rationale: "License and pragma statements"

  - id: "CA_COMMENTS"
    type: "COMMENT"
    lines: [5, 12, 17, 20, 23, 32, 33, 34, 35, 36, 37, 38, 39, 40, 44, 55, 58, 65, 66, 67, 68, 72, 75]
    security_function: "UNRELATED"
    rationale: "Inline comments and NatSpec documentation"

  - id: "CA_DECLARATIONS"
    type: "DECLARATION"
    lines: [4, 6, 7, 8, 9, 10, 14, 21, 24, 41, 69, 70, 71]
    security_function: "UNRELATED"
    rationale: "Contract, enum, mapping, and function signature declarations"

  - id: "CA_EVENT_DEFS"
    type: "EVENT_DEF"
    lines: [26]
    security_function: "UNRELATED"
    rationale: "Event declaration"

  - id: "CA_SYNTAX"
    type: "SYNTAX"
    lines: [63, 81, 86]
    security_function: "UNRELATED"
    rationale: "Closing braces"

summary:
  total_code_acts: 18
  total_lines_covered: 63  # excludes 24 empty lines (3, 11, 13, 15, 16, 19, 22, 25, 27, 31, 39, 43, 49, 50, 51, 54, 57, 60, 64, 73, 74, 79, 82, 87)

  by_security_function:
    ROOT_CAUSE: 1
    SECONDARY_VULN: 1
    PREREQ: 0
    BENIGN: 11
    UNRELATED: 5  # batched

  by_code_act_type:
    CTRL_FLOW: 3
    INPUT_VAL: 2
    DECLARATION: 2  # 1 ROOT_CAUSE + 1 batched UNRELATED
    INITIALIZATION: 1
    STATE_MOD: 1
    EXT_CALL: 1
    COMPUTATION: 2
    EVENT_EMIT: 1
    ACCESS_CTRL: 1
    DIRECTIVE: 1
    COMMENT: 1
    EVENT_DEF: 1
    SYNTAX: 1

  root_causes:
    - id: "CA6"
      line: 53
      type: "INPUT_VAL"
      description: "Validation check accepts zero roots - passes when both root and acceptedRoot are zero"

  secondary_vulns:
    - id: "CA13"
      lines: [83, 84, 85]
      type: "ACCESS_CTRL"
      description: "Missing access control on setAcceptedRoot"
      vuln_type: "access_control"

  prerequisites: []

  vulnerable_lines_mapping:
    53: "CA6 - ROOT_CAUSE - validation check accepts zero roots"

  # For scoring: lookup line → code_act → security_function
  # This avoids marking closing braces as ROOT_CAUSE; the code act is the meaningful unit.
  # Scoring: if model references any line in a code act, lookup code act's security_function.
line_to_code_act:
  # Directives (UNRELATED)
  1: "CA_DIRECTIVES"
  2: "CA_DIRECTIVES"
  # Contract/enum declarations (UNRELATED)
  4: "CA_DECLARATIONS"
  6: "CA_DECLARATIONS"
  7: "CA_DECLARATIONS"
  8: "CA_DECLARATIONS"
  9: "CA_DECLARATIONS"
  10: "CA_DECLARATIONS"
  # Comments (UNRELATED)
  5: "CA_COMMENTS"
  12: "CA_COMMENTS"
  17: "CA_COMMENTS"
  20: "CA_COMMENTS"
  23: "CA_COMMENTS"
  32: "CA_COMMENTS"
  33: "CA_COMMENTS"
  34: "CA_COMMENTS"
  35: "CA_COMMENTS"
  36: "CA_COMMENTS"
  37: "CA_COMMENTS"
  38: "CA_COMMENTS"
  # Line 39: empty
  40: "CA_COMMENTS"
  44: "CA_COMMENTS"
  55: "CA_COMMENTS"
  58: "CA_COMMENTS"
  65: "CA_COMMENTS"
  66: "CA_COMMENTS"
  67: "CA_COMMENTS"
  68: "CA_COMMENTS"
  72: "CA_COMMENTS"
  75: "CA_COMMENTS"
  # Declarations (UNRELATED)
  14: "CA_DECLARATIONS"
  21: "CA_DECLARATIONS"
  24: "CA_DECLARATIONS"
  41: "CA_DECLARATIONS"
  69: "CA_DECLARATIONS"
  70: "CA_DECLARATIONS"
  71: "CA_DECLARATIONS"
  # Event definition (UNRELATED)
  26: "CA_EVENT_DEFS"
  # Syntax - closing braces (UNRELATED)
  63: "CA_SYNTAX"
  81: "CA_SYNTAX"
  86: "CA_SYNTAX"
  # === SECURITY-RELEVANT CODE ACTS ===
  # CA1: acceptedRoot declaration (BENIGN - enabling condition)
  18: "CA1"
  # CA2: Constructor (BENIGN - missed mitigation)
  28: "CA2"
  29: "CA2"
  30: "CA2"
  # CA3: Hash computation (BENIGN)
  42: "CA3"
  # CA4: Replay protection (BENIGN)
  45: "CA4"
  46: "CA4"
  47: "CA4"
  48: "CA4"
  # CA5: Root computation call (BENIGN)
  52: "CA5"
  # CA6: Root validation (ROOT_CAUSE)
  53: "CA6"
  # CA7: Mark processed (BENIGN)
  56: "CA7"
  # CA8: External call (BENIGN - impact path)
  59: "CA8"
  # CA9: Event emission (BENIGN)
  61: "CA9"
  # CA10: Return statement (BENIGN)
  62: "CA10"
  # CA11: Zero root conditional (BENIGN)
  76: "CA11"
  77: "CA11"
  78: "CA11"
  # CA12: Default keccak return (BENIGN)
  80: "CA12"
  # CA13: setAcceptedRoot (SECONDARY_VULN)
  83: "CA13"
  84: "CA13"
  85: "CA13"

# Quick lookup: code_act_id → security_function
code_act_security_functions:
  CA1: "BENIGN"
  CA2: "BENIGN"
  CA3: "BENIGN"
  CA4: "BENIGN"
  CA5: "BENIGN"
  CA6: "ROOT_CAUSE"
  CA7: "BENIGN"
  CA8: "BENIGN"
  CA9: "BENIGN"
  CA10: "BENIGN"
  CA11: "BENIGN"
  CA12: "BENIGN"
  CA13: "SECONDARY_VULN"
  CA_DIRECTIVES: "UNRELATED"
  CA_COMMENTS: "UNRELATED"
  CA_DECLARATIONS: "UNRELATED"
  CA_EVENT_DEFS: "UNRELATED"
  CA_SYNTAX: "UNRELATED"
