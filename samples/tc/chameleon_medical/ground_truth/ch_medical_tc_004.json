{
  "is_vulnerable": true,
  "vulnerability_type": "reentrancy",
  "vulnerable_functions": [
    "append_availableresources"
  ],
  "severity": "critical",
  "description": "Curve Finance pools compiled with vulnerable Vyper versions (0.2.15, 0.2.16, 0.3.0) had a compiler bug that broke the @nonreentrant decorator. Attacker exploited reentrancy in add_liquidity() function by calling it recursively during ETH transfer callback, minting LP tokens twice and draining ~$70M across multiple pools.",
  "root_cause": "Vyper compiler versions 0.2.15, 0.2.16, and 0.3.0 had a bug in the @nonreentrant decorator implementation. When multiple functions used the decorator, the compiler generated incorrect bytecode that checked the wrong storage slot for reentrancy state. This made the protection completely ineffective, allowing reentrancy despite the decorator being present in the source code.",
  "attack_scenario": "Attacker takes 80,000 ETH flash loan from Balancer. Calls add_liquidity() with 40,000 ETH. During ETH operations in add_liquidity(), contract transfers ETH which triggers attacker's receive() function. Attacker calls add_liquidity() again recursively with another 40,000 ETH. Due to Vyper compiler bug, the @nonreentrant decorator fails to prevent this. Pool mints LP tokens twice for overlapping deposits. Attacker removes liquidity with inflated LP balance, extracting more assets than deposited.",
  "fix_description": "Upgrade to patched Vyper versions (0.3.1+, 0.2.17+) that fix the @nonreentrant compiler bug. Recompile all affected contracts with fixed compiler. Redeploy pools with corrected bytecode. Add additional contract-level reentrancy guards as defense-in-depth. Strictly follow Checks-Effects-Interactions pattern. Minimize external calls in critical functions. Test with multiple compiler versions.",
  "language": "solidity",
  "vulnerable_lines": [
    59,
    102
  ],
  "sub_category": ""
}